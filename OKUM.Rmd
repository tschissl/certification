Analyzing submitted data for OKUM, GAS or MUH-1
========================================================
The data for this interlaboratory comparison based certification of property values were analysed by 36 labs following the nested design approached as proposed the IAG certification protocol. Participating labs received 3 packages of OKUM and MUH-1 respectively and one package of GAS. The latter was supplied as a "traceablility" sample and is here used for quality control purposes. It was the task of the labs to prepare 2 make two independent sample preparations (i.e. digstions) of each packet and analyse the preparation on two different days. Labs thus should have submitted 12 values (3x2x2 PacketxPrepxDay). 

```{r defining the measurand and RM}
refmat <- 'MUH' # defining the RM
measur <- 'Al2O3' # defining the measurand
'%p%' <- function(a, b) {as.character(paste (a, b, sep =""))} # the measureands have different endings depending on which RM: OKUM not extention, MUH extention ".1" and GAS has the extention ".2"
switch(
    refmat,
    GAS = rm1 <- 2,
    MUH = rm1 <- 1,
    OKUM = rm1 <- 0
  )
  if(rm1 > 0) 
  {measurand <- measur %p% '.' %p% rm1
  } else 
  {
    measurand <- measur
  }
``` 

# measurand selected `r measurand` for candiate reference material `r refmat`


#### Importing the data and assigning factors

```{r results='hide'}
library(ggplot2) # needed for most plots in this document
# library(devtools) #needed for "order_by"
# install_github("plotflow", "trinker")
library(plotflow) #needed for "order_by" # install_github("plotflow", "trinker")
library(metRology) #for mandel k and h calculations
library(ape) # needed for varcomp (variance component) extraction
library(nlme) # needed for lme
require(plyr) # needed for ddply

# Data for certification project were gathered and joined in Excel. The files were exported from Excel as .csv files to make the universially readable. For this markdown the data is stored in the "root/documents" directory.
# Data for GAS, OKUM and MUH-1 are merged together with a methods file ('OKUM.method') into a universal data frame file named 'GOM'

GAS <- read.csv("~/GitHub/certification/GAS.csv", sep=";")
OKUM <- read.csv("~/GitHub/certification/OKUM.csv", sep=";")
MUH <- read.csv("~/GitHub/certification/MUH.csv", sep=";")
OKUM.methods <- read.csv("~/GitHub/certification/OKUM methods.csv", sep=";")
GOM <- data.frame(OKUM, MUH[6:60], GAS[6:60])
GOM <- merge(GOM, OKUM.methods) # merging all data and all methods
#defining factors 
GOM$Lab <- as.factor(GOM$Lab)
GOM$Packet <- as.factor(GOM$Packet)
GOM$Prep <- as.factor(GOM$Prep)
GOM$day <- as.factor(GOM$day)
GOM$names <- as.factor(GOM$names)
GOMorig <- GOM  #keeping the original file
```

#### defining the plotting theme

```{r}
mytheme <- theme_grey() + theme(plot.title = element_text(colour = "black", size = rel(2))) + theme(axis.title.x = element_text(size = rel(1.8)))+ theme(axis.title.y = element_text(size = rel(1.8))) +theme(axis.text.x = element_text(size = rel(1.5))) + theme(axis.text.y = element_text(size = rel(1.5))) + theme(legend.title = element_text(size = rel(1))) +theme(legend.text = element_text(size = rel(0.8)))
```
#### initial calculations with complete data set

```{r creating means}
## means over packets within lab 
meanGOM <- function(x) mean(x, na.rm=TRUE) # defining a function for further calcuations
sdGOM <- function(x) sd(x, na.rm=TRUE) # defining a function for further calcuations, here for calculating standard deviations neede for Youden plot
meanGOM.packet <- ddply(GOM, c("Lab", "Packet"), numcolwise(meanGOM)) # calculated the median for each Packet within each Lab by calculating the median of days and preparations lumped together
## median over median of packets within lab
GOM.mean <- ddply(meanGOM.packet, c("Lab"), numcolwise(meanGOM))
```
```{r creating median}
## median over packets within lab 
require(plyr)
medianGOM <- function(x) median(x, na.rm=TRUE)
medianGOM.packet <- ddply(GOM, c("Lab", "Packet"), numcolwise(medianGOM))
GOM.sd <- ddply(medianGOM.packet, c("Lab"), numcolwise(sdGOM))
## median over median of packets within lab
GOM.median <- ddply(medianGOM.packet, c("Lab"), numcolwise(medianGOM))
```
#### defining the function for plotting methods vs. measurand mass fraction. Sample preparation methods are also marked in the plot.
```{r plot_method function plotting measurand vs. method}
### function plot_method defined here. Automated plot of methods boxplots sorted by increasing method mean. Enter with plot_method=('xx') #######
plot_method <- function(x) {
  element <- x
  '%p%' <- function(x, y) {as.character(paste (x, y, sep =""))}
  prep <-  'Prep.'
  method <- 'Method.'
  anal.prep <- prep %p% measur
  anal.method <- method %p% measur
  anal <- GOM[[element]]
  anal.prep <- GOM[[anal.prep]]
  anal.method <- GOM[[anal.method]]
  analyte <- data.frame(GOM$Lab, GOM$names, anal, anal.prep, anal.method )
  analyte <- na.omit(analyte)
  p <- ggplot(reorder_by(anal.method, ~anal, analyte, mean), aes(anal.method, anal)) + geom_boxplot(outlier.shape = NA) + geom_jitter(aes(colour=anal.prep), size = 4.5, position = position_jitter(width = .2))
  p + xlab("method") + ylab("mg/kg or g/100g") + labs(title = element) + labs(colour = "Prep") + mytheme
}
```
```{r plot_lab function plot measurand vs. lab}
###### function plot_lab #### 
# defined here. Automated plot of lab boxplots sorted by increasing lab mean and Horwitz function. Enter with plot_lab=('xx')
plot_lab <- function(x, type) {
  element <- x
  '%p%' <- function(x, y) {as.character(paste (x, y, sep =""))}
  prep <-  'Prep.'
  method <- 'Method.'
  anal.prep <- prep %p% measur
  anal.method <- method %p% measur
  anal <- GOM[[element]]
  anal.prep <- GOM[[anal.prep]]
  anal.method <- GOM[[anal.method]]
  analyte <- data.frame(GOM$Lab, GOM$names, anal, anal.prep, anal.method )
  analyte <- na.omit(analyte)
  avg <- median(tapply(analyte$anal, analyte$GOM.Lab, mean, na.rm=TRUE), na.rm=TRUE)
  switch(type, 
         M = hor <- 1*(0.01*avg)^0.8495, 
         T = hor <- 10000*1*(0.01*avg/10000)^0.8495)
  # hor <- 1*(0.01*avg)^0.8495
  u.hor <- avg + hor
  u.2hor <- avg + 2*hor
  l.hor <- avg - hor
  l.2hor <- avg - 2*hor
  p <- ggplot(reorder_by(GOM.Lab, ~anal, analyte, mean), aes(GOM.Lab, anal)) + geom_abline(intercept = avg, slope = 0) + geom_abline(intercept = u.2hor, slope = 0, linetype ="dotted") + geom_abline(intercept = l.2hor, slope = 0, linetype = "dotted") + geom_abline(intercept = u.hor, slope = 0, linetype ="dashed") + geom_abline(intercept = l.hor, slope = 0, linetype = "dashed")
  p <- p + geom_boxplot(aes(fill=anal.method)) + geom_point(size=4) + geom_point(aes(colour=anal.prep), size = 3.5) 
  p + xlab("lab") + ylab("mg/kg or g/100g") + labs(title = element) + labs(colour = "Prep") + geom_smooth(aes(group=1)) + mytheme
}
```

#### defining the function of Youden plots

```{r plot_youd functin for youden plot}
plot_youd <- function(a, y, z) { # a = measurand, y and z ref
  '%p%' <- function(a, b) {as.character(paste (a, b, sep =""))}
  switch(
    y,
    GAS = rm1 <- 2,
    MUH = rm1 <- 1,
    OKUM = rm1 <- 0
  )
  switch(
    z,
    GAS = rm2 <- 2,
    MUH = rm2 <- 1,
    OKUM = rm2 <- 0
  )
  if(rm1 > 0) 
  {RM1 <- a %p% '.' %p% rm1
  } else 
  {
    RM1 <- a
  }
  if(rm2 > 0) 
  {RM2 <- a %p% '.' %p% rm2
  } else 
  {
    RM2 <- a
  }
 if(rm1 > 1)
   {RM1.s <- GOM.sd[[RM1]]} else
     {RM1.s <- GOM.sd[[RM1]]/sd(GOM.median[[RM1]], na.rm = TRUE)}# calculating the normalised standard deviations
 if(rm2 > 1)
   {RM2.s <- GOM.sd[[RM2]]} else
     {RM2.s <- GOM.sd[[RM2]]/sd(GOM.median[[RM2]], na.rm = TRUE)}# calculating the normalised standard deviations
  RM1 <- GOM.median[[RM1]]
  RM1 <- (RM1-median(RM1, na.rm = TRUE))/sd(RM1, na.rm = TRUE) #calculating z-scores
  RM2 <- GOM.median[[RM2]]
  RM2 <- (RM2-median(RM2, na.rm = TRUE))/sd(RM2, na.rm = TRUE) #calculating z-scores
  RM <- data.frame(GOM.median$Lab, RM1, RM2, RM1.s, RM2.s) # creating a data frame for the measurand
  # RM <- na.omit(RM) # removing all "NA"
  p <- ggplot(RM, aes(RM1, RM2, label = GOM.median.Lab))  + xlim(-5, 5) + ylim(-5,5) + 
    geom_point(aes(colour=factor(GOM.median.Lab)), size = 4)
  p <- p + xlab(y) + ylab(z) + labs(title = a) + labs(colour = "GOM.median.Lab") + mytheme + 
    geom_abline(intercept = 0, slope = 1) +  geom_abline(intercept = 2.8284, slope = 1) +  
    geom_abline(intercept = - 2.8284, slope = 1) +  geom_abline(intercept = 2.8284, slope = - 1) +  
    geom_abline(intercept = -2.8284, slope = - 1) + geom_text(data = NULL, x = -0.5, y = 2.85, label = "z = 2") + 
    geom_text(aes(colour=factor(GOM.median.Lab)), hjust=1, vjust=0) + theme(legend.position="none") #+ stat_density2d(aes(fill = ..level..), geom="polygon")
  p  + geom_errorbar(aes(ymin=RM2-RM2.s, ymax=RM2+RM2.s)) + geom_errorbarh(aes(xmin=RM1-RM1.s, xmax=RM1+RM1.s))
  
}

```

```{r summary as is for indiviual measurand}
summary(GOM[[measurand]], na.rm=TRUE, digits=4) # with values without outlier removal
mean.before <- mean(GOM.mean[[measurand]], na.rm=TRUE)
median.before <- median(GOM.median[[measurand]], na.rm=TRUE)
```
The `r measurand` mean of the Lab means is **`r round(mean.before, 4)`** g/100 g  
The `r measurand` median of the Lab+Package medians is **`r round(median.before, 4)`** g/100 g  


```{r methods and lab plot as is, fig.width=10, fig.height=4}
plot_method(measurand); plot_lab(measurand,'M') ## M for majors, T for traces
```
```{r fig.width=6, fig.height=6}
plot_youd(measur, 'GAS', 'OKUM'); plot_youd(measur, 'MUH', 'OKUM')
```
#### Mandel k barplot displays the within lab performance relative to all participating labs using the median over packages
```{r mandel k, fig.width=10, fig.height=6}
k <- with(medianGOM.packet, mandel.kh(medianGOM.packet[[measurand]], g=Lab, type="k"))     
barplot(k, las=2, col=1:4)
```

### Outlier rejection
#### Removing ouliers lab based on Youden plot and Mandel's k (lab performance)

```{r outlier removal, fig.width=10, fig.height=6}
outlier <- c(12, 14, 31) ## defining the outlying lab here with lab#
leng <- length(outlier) ## counting the number of outliers for loop
for(i in seq(leng)) ##  looping
{
  GOM[[measurand]] <- ifelse(GOM$Lab==outlier[i], NA, GOM[[measurand]]) ## replacing values of outlying lab with "NA" and defining new GOM
  message("Lab ", outlier[i], " was removed")
  print(summary(GOM[[measurand]], na.rm=TRUE, digits=4))
  }
plot_lab(measurand, 'M') # replotting without outlier, M for majors and T for traces
```
## Calculating mean and median of property value

```{r calculating mean and median of property value}
summary(GOM[[measurand]], na.rm=TRUE, digits=4)
mean <- mean(tapply(GOM[[measurand]], GOM$Lab, mean, na.rm=TRUE), na.rm=TRUE) # mean of lab means after outlier removal
median.before <- median(GOM.median[[measurand]], na.rm=TRUE) # median of measurand w/o outlier removal
medianGOM.packet.after <- ddply(GOM, c("Lab", "Packet"), numcolwise(medianGOM)) # median Lab and Packets after outlier removal
## median over median of packets within lab
GOM.median.after <- ddply(medianGOM.packet.after, c("Lab"), numcolwise(medianGOM)) # creating a new table of median of labs after outlier removal for entire table (all measurands)
GOM.median.after <- merge(GOM.median.after, OKUM.methods, by="Lab")
median.after <- median(GOM.median.after[[measurand]], na.rm=TRUE) # median of the individual measurand after outlier removal
## calculating method parameters
  '%p%' <- function(x, y) {as.character(paste (x, y, sep =""))}
  prep <-  'Prep.'
  method <- 'Method.'
  anal.prep <- prep %p% measur
  anal.method <- method %p% measur
  anal <- GOM.median.after[[measurand]]
  anal.prep <- GOM.median.after[[anal.prep]]
  anal.method <- GOM.median.after[[anal.method]]
  analyte <- data.frame(GOM.median.after$Lab, GOM.median.after$names, anal, anal.prep, anal.method )
  analyte <- na.omit(analyte)
  bymethod.n <- ddply(analyte, c("anal.method"), summarise, 
                      N=length(anal), 
                      mean = round(mean(anal), 3), 
                      median = round(median(anal), 3), 
                      sd = round(sd(anal),3), 
                      se = round(sd/sqrt(N),3))
```


## Comparisons of method parameters based on median of the Lab+packet medians after outlier removal
```{r method comparison output}
print(bymethod.n)
```

## Measurement uncertainty estimations of property value

```{r measurement uncertainty of data before outlier rejection}
medianGOM.packet$Lab <- as.factor(medianGOM.packet$Lab) # using only the median of the 3 packages per lab
medianGOM.packet$Packet <- as.factor(medianGOM.packet$Packet)
anal <- medianGOM.packet[[measurand]]
DF.lme <- data.frame(medianGOM.packet$Lab, medianGOM.packet$Packet, medianGOM.packet[[measurand]])
DF.lme <- na.omit(DF.lme)
names(DF.lme) <- c("Lab", "Packet", "measurand")
GOM.lme <- lme(measurand ~ 1, random = ~ 1|Lab/Packet, data=DF.lme) # linear model with random effects
sL2 <- varcomp(GOM.lme, FALSE, FALSE)[[1]] # between-laboratory variance
sbb2 <- varcomp(GOM.lme, FALSE, FALSE)[[2]] # between bottle variance
sr2 <- varcomp(GOM.lme, FALSE, FALSE)[[3]] # repeatability standard deviation
n.p <- dim(DF.lme)[1] # number of obervations
p <- length(unique(DF.lme$Lab)) # haven't found a better way how to extract the number of labs (number of groups)
r <- length(unique(DF.lme$Packet))
u1 <- sqrt(sL2/p+sbb2/p/r+sr2/p/r/4) # calculating the standard uncertainty of characterization
u2 <- attr(GOM.lme$fixDF,"varFixFact") # gives the same results as u, amazing!
plot(DF.lme)
```
```{r measurement uncertainty of data after outlier rejection}
medianGOM.packet.after$Lab <- as.factor(medianGOM.packet$Lab) # using only the median of the 3 packages per lab
medianGOM.packet.after$Packet <- as.factor(medianGOM.packet$Packet)
anal <- medianGOM.packet.after[[measurand]]
DF.lme <- data.frame(medianGOM.packet.after$Lab, medianGOM.packet.after$Packet, medianGOM.packet.after[[measurand]])
DF.lme <- na.omit(DF.lme)
names(DF.lme) <- c("Lab", "Packet", "measurand")
GOM.lme <- lme(measurand ~ 1, random = ~ 1|Lab/Packet, data=DF.lme) # linear model with random effects
sL2.a <- varcomp(GOM.lme, FALSE, FALSE)[[1]] # between-laboratory variance
sbb2.a <- varcomp(GOM.lme, FALSE, FALSE)[[2]] # between bottle standard deviation
sr2.a <- varcomp(GOM.lme, FALSE, FALSE)[[3]] # repeatability standard deviation
n.p <- dim(DF.lme)[1] # number of obervations
p <- length(unique(DF.lme$Lab)) # haven't found a better way how to extract the number of labs (number of groups)
r <- length(unique(DF.lme$Packet))
t.value <- qt(0.975,df=p-1)
u1.a <- sqrt(sL2.a/p+sbb2.a/p/r+sr2.a/p/r/4) # calculating the standard uncertainty of characterization
u2.a <- attr(GOM.lme$fixDF,"varFixFact") # gives the same results as u1, amazing!
plot(DF.lme)
```
 
### tests for normal distribution
```{r QQ plot}
qqnorm(GOM.median.after[[measurand]])
qqline(GOM.median.after[[measurand]])
```

## Comparisons of property value calculations for `r refmat` and measurand `r measurand` 
### after removal of outlying lab(s) # `r outlier`
type |  before | after | unit 
:----| :------- | :-------- |:------ | :--------
**mean** |`r round(mean.before, 4)`  |`r round(mean, 4)` |g/100g
**median** | `r round(median.before, 4)` | **`r round(median.after, 4)`**| g/100g


### performance characteristics for `r refmat` and measurand `r measurand` 
type | variance before | variance after outlier rejection 
:----| :------- | :-----------
between-laboratory variance | `r sL2` | `r sL2.a` 
between-bottle variance | `r sbb2` | `r sbb2.a`
repeatability variance | `r sr2` | `r sr2.a` 

### mesasurment uncertainty
type |  before |  after outlier rejection | alternative calculation
:----| :------- | :----------- | :--------
standard uncertainty | `r u2` | `r u1.a` | `r u2.a`
expanded standard uncertainty |-|-| **`r u2.a*t.value`** *k* = `r round(t.value, 2)`


### final result based on median for property value and measurement uncertainty based on variance components
The `r measurand` median of the Lab+packet medians after outlier removal is **`r round(median.after, 4)`** g/100 g   
The expanded standard uncertainty for the assigned value of `r measurand` is **`r u2.a*t.value`** with k = `r round(t.value, 2)`  
exluded labs for `r measurand` is/are `r outlier`  
labs remaining for calculations `r p`  
#### comments
labs #12 and #14 based on Youden plot and PP-XRF, lab #31 removed because of bad performance Madel's k and PP-XRF